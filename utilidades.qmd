# Utilidades Diversas

Esta secci√≥n cubre herramientas que mejoran significativamente la experiencia general en terminal, desde correcci√≥n autom√°tica hasta personalizaci√≥n avanzada del prompt.

## tealdeer - Ejemplos pr√°cticos de comandos {#sec-tealdeer}

`tealdeer` es una implementaci√≥n moderna y r√°pida de `tldr`, compatible con las p√°ginas tldr pero escrita en Rust.

::: {.callout-warning}
## ‚ö†Ô∏è Migraci√≥n desde tldr

La f√≥rmula original de `tldr` en Homebrew ha sido marcada como **obsoleta**. Las alternativas recomendadas son:

**Opci√≥n 1: tealdeer (recomendado para Homebrew)**
```bash
# Desinstalar tldr si est√° instalado
brew uninstall tldr 2>/dev/null || true

# Instalar tealdeer (implementaci√≥n en Rust)
brew install tealdeer
```

**Opci√≥n 2: tldr v√≠a npm (versi√≥n oficial mantenida)**
```bash
npm install -g tldr
```
:::

### Uso b√°sico

```bash
# Ver ejemplos de un comando (usa comando 'tldr' igual que antes)
tldr git
tldr curl
tldr find

# Actualizar base de datos
tldr --update

# Buscar comando por funcionalidad
tldr --search "compress"
tldr --search "network"

# Plataforma espec√≠fica
tldr -p linux tar
tldr -p macos ls
```

### Configuraci√≥n avanzada

```bash
# Configurar tema
tldr --theme base16

# Idioma espec√≠fico (si est√° disponible)  
tldr -L es git

# Configuraci√≥n en ~/.config/tealdeer/config.toml
[display]
compact = false
use_pager = false

[updates]
auto_update = true
auto_update_interval_hours = 24

[style]
description = "white"
code = "green"
parameter = "cyan"
```

### Comparaci√≥n de alternativas

| Implementaci√≥n | Instalaci√≥n | Velocidad | Estado |
|----------------|-------------|-----------|---------|
| `tealdeer` | `brew install` | ‚ö° Muy r√°pida | ‚úÖ Mantenido |
| `tldr` (npm) | `npm install -g` | üöÄ R√°pida | ‚úÖ Oficial |
| `tldr` (brew) | ‚ùå Obsoleto | üêå Regular | ‚ùå Deprecated |

---

## thefuck - Corrector autom√°tico {#sec-thefuck}

thefuck corrige autom√°ticamente comandos mal escritos.

### Configuraci√≥n inicial

```bash
# Agregar a ~/.zshrc o ~/.bashrc
eval $(thefuck --alias)
# O crear alias personalizado
eval $(thefuck --alias fix)
```

### Ejemplos de uso

```bash
# Comando mal escrito
$ gut push
git: 'gut' is not a git command

$ fuck
git push [enter/‚Üë/‚Üì/ctrl+c]

# Puerto ocupado
$ python -m http.server 8000
OSError: [Errno 48] Address already in use

$ fuck
python -m http.server 8001 [enter/‚Üë/‚Üì/ctrl+c]
```

### Configuraci√≥n avanzada

Archivo `~/.config/thefuck/settings.py`:

```python
# Configuraci√≥n personalizada
rules = ['git_push', 'python_command', 'ls_lah', 'cd_mkdir']
exclude_rules = ['rm_root']
require_confirmation = True
wait_command = 3
history_limit = 1000

# Alias personalizado
alias = 'fix'
```

---

## cowsay - Arte ASCII divertido {#sec-cowsay}

cowsay genera arte ASCII con mensajes personalizados.

### Uso b√°sico

```bash
# Mensaje b√°sico
cowsay "Hola mundo"

# Diferentes animales
cowsay -f dragon "Soy un drag√≥n"
cowsay -f tux "¬°Linux!"

# Listar animales disponibles
cowsay -l
```

### Expresiones de la vaca

```bash
# Diferentes estados de √°nimo
cowsay -b "Ojos de Borg"      # Borg
cowsay -d "Muerto"            # Dead
cowsay -g "Codicioso"         # Greedy
cowsay -p "Paranoico"         # Paranoid
cowsay -s "Stoned"            # Stoned
cowsay -t "Cansado"           # Tired
cowsay -w "Cableado"          # Wired
cowsay -y "Joven"             # Young
```

### Integraci√≥n con otras herramientas

```bash
# Con fortune (si est√° instalado)
fortune | cowsay

# Con fecha
date | cowsay -f tux

# En MOTD del sistema
echo "$(whoami), bienvenido a $(hostname)" | cowsay -f dragon

# Pipeline divertido
curl -s "https://api.quotegarden.com/api/v3/quotes/random" | \
jq -r '.data.quoteText' | cowsay -f elephant
```

---

## direnv - Variables de entorno por directorio {#sec-direnv}

direnv carga autom√°ticamente variables de entorno al entrar a directorios.

### Configuraci√≥n inicial

```bash
# Agregar a ~/.zshrc
eval "$(direnv hook zsh)"

# Para bash
eval "$(direnv hook bash)"
```

### Uso b√°sico

```bash
# Crear archivo .envrc en tu proyecto
echo 'export DATABASE_URL="postgres://localhost/mydb"' > .envrc
echo 'export DEBUG=true' >> .envrc

# Permitir el archivo
direnv allow

# Al entrar al directorio, las variables se cargan autom√°ticamente
# Al salir, se descargan
```

### Ejemplos avanzados

#### Proyecto Python

```bash
# .envrc para proyecto Python
export VIRTUAL_ENV="$PWD/.venv"
export PATH="$VIRTUAL_ENV/bin:$PATH"
export PYTHONPATH="$PWD/src:$PYTHONPATH"

# Variables de desarrollo
export FLASK_ENV=development
export DATABASE_URL="sqlite:///dev.db"

# Activar virtualenv si existe
if [ -d "$VIRTUAL_ENV" ]; then
    source "$VIRTUAL_ENV/bin/activate"
fi
```

#### Proyecto Node.js

```bash
# .envrc para proyecto Node.js
export NODE_ENV=development
export PORT=3000

# Usar versi√≥n espec√≠fica de Node con nvm
use node 18.17.0

# Variables de API
export API_KEY="dev-api-key"
export REDIS_URL="redis://localhost:6379"
```

#### Proyecto con Docker

```bash
# .envrc para proyecto Docker
export COMPOSE_PROJECT_NAME="myapp"
export DOCKER_BUILDKIT=1

# Variables para docker-compose
export POSTGRES_DB=myapp_dev
export POSTGRES_USER=developer
export POSTGRES_PASSWORD=devpass

# Path para herramientas locales
PATH_add ./scripts
PATH_add ./node_modules/.bin
```

---

## starship - Prompt personalizable {#sec-starship}

starship es un prompt de terminal minimalista y r√°pido.

### Configuraci√≥n inicial

```bash
# Agregar a ~/.zshrc
eval "$(starship init zsh)"

# Para bash
eval "$(starship init bash)"
```

### Configuraci√≥n b√°sica

Archivo `~/.config/starship.toml`:

```toml
[character]
success_symbol = "[‚ûú](bold green)"
error_symbol = "[‚ûú](bold red)"

[directory]
truncation_length = 3
truncation_symbol = "‚Ä¶/"

[git_branch]
symbol = "üå± "
format = "on [$symbol$branch]($style) "

[git_status]
conflicted = "üè≥"
ahead = "üèéüí®"
behind = "üò∞"
diverged = "üòµ"
untracked = "ü§∑‚Äç"
stashed = "üì¶"
modified = "üìù"
staged = '[++\($count\)](green)'
renamed = "üëÖ"
deleted = "üóë"

[nodejs]
symbol = "‚¨¢ "
format = "via [$symbol($version )]($style)"

[python]
symbol = "üêç "
format = 'via [${symbol}${pyenv_prefix}(${version} )(\($virtualenv\) )]($style)'

[rust]
symbol = "ü¶Ä "
format = "via [$symbol($version )]($style)"

[docker_context]
symbol = "üê≥ "
format = "via [$symbol$context]($style) "
```

### Presets disponibles

```bash
# Ver presets disponibles
starship preset --list

# Aplicar preset
starship preset nerd-font-symbols -o ~/.config/starship.toml
starship preset tokyo-night -o ~/.config/starship.toml
```

---

## Workflows con utilidades

### Script de setup de entorno

```bash
#!/bin/bash
# dev-setup.sh - Configurar entorno de desarrollo

setup_git() {
    echo "üîß Configurando Git..."
    
    # Configuraci√≥n b√°sica si no existe
    if ! git config --global user.name >/dev/null 2>&1; then
        read -p "Nombre para Git: " git_name
        git config --global user.name "$git_name"
    fi
    
    if ! git config --global user.email >/dev/null 2>&1; then
        read -p "Email para Git: " git_email
        git config --global user.email "$git_email"
    fi
    
    # Aliases √∫tiles
    git config --global alias.st status
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.unstage 'reset HEAD --'
}

setup_shell() {
    echo "üêö Configurando shell..."
    
    # Backup de configuraci√≥n existente
    [ -f ~/.zshrc ] && cp ~/.zshrc ~/.zshrc.backup
    
    # Configurar starship
    echo 'eval "$(starship init zsh)"' >> ~/.zshrc
    
    # Configurar direnv
    echo 'eval "$(direnv hook zsh)"' >> ~/.zshrc
    
    # Configurar thefuck
    echo 'eval $(thefuck --alias)' >> ~/.zshrc
    
    # Aliases √∫tiles
    cat >> ~/.zshrc << 'EOF'
# Aliases √∫tiles
alias ll='eza -la --git'
alias cat='bat'
alias find='fd'
alias grep='rg'

# Funciones √∫tiles
help() {
    tldr "$1" 2>/dev/null || man "$1"  # tldr funciona igual con tealdeer
}
EOF
}

setup_project_templates() {
    echo "üìÅ Creando templates de proyecto..."
    
    TEMPLATES_DIR="$HOME/.project-templates"
    mkdir -p "$TEMPLATES_DIR"
    
    # Template para Python
    mkdir -p "$TEMPLATES_DIR/python"
    cat > "$TEMPLATES_DIR/python/.envrc" << 'EOF'
export PYTHONPATH="$PWD/src:$PYTHONPATH"
export VIRTUAL_ENV="$PWD/.venv"
export PATH="$VIRTUAL_ENV/bin:$PATH"

if [ -d "$VIRTUAL_ENV" ]; then
    source "$VIRTUAL_ENV/bin/activate"
fi
EOF
    
    # Template para Node.js
    mkdir -p "$TEMPLATES_DIR/nodejs"
    cat > "$TEMPLATES_DIR/nodejs/.envrc" << 'EOF'
export NODE_ENV=development
export PATH="$PWD/node_modules/.bin:$PATH"

use node 18
EOF
    
    echo "Templates creados en $TEMPLATES_DIR"
}

# Funci√≥n principal
main() {
    echo "üöÄ Configurando entorno de desarrollo..."
    
    setup_git
    setup_shell
    setup_project_templates
    
    echo "‚úÖ Configuraci√≥n completada!"
    echo "üí° Reinicia tu terminal para aplicar los cambios"
    
    # Mensaje motivacional
    echo "¬°Listo para programar!" | cowsay -f tux
}

main "$@"
```

### Sistema de notificaciones inteligente

```bash
#!/bin/bash
# smart-notify.sh - Sistema de notificaciones basado en contexto

NOTIFY_FILE="$HOME/.local/notifications"
LAST_COMMAND_FILE="$HOME/.last_command"

# Funci√≥n para enviar notificaci√≥n
send_notification() {
    local title="$1"
    local message="$2"
    local urgency="${3:-normal}"
    
    # macOS
    if command -v osascript >/dev/null; then
        osascript -e "display notification \"$message\" with title \"$title\""
    # Linux
    elif command -v notify-send >/dev/null; then
        notify-send -u "$urgency" "$title" "$message"
    fi
    
    # Log para debug
    echo "[$(date)] $title: $message" >> "$NOTIFY_FILE"
}

# Notificar cuando comando tarda mucho
notify_long_command() {
    local cmd="$1"
    local duration="$2"
    
    if [ "$duration" -gt 30 ]; then
        send_notification "Comando completado" "\"$cmd\" termin√≥ en ${duration}s"
    fi
}

# Hook para .zshrc
precmd() {
    local exit_code=$?
    local end_time=$(date +%s)
    
    if [ -f "$LAST_COMMAND_FILE" ]; then
        local start_time=$(cat "$LAST_COMMAND_FILE")
        local duration=$((end_time - start_time))
        
        if [ $exit_code -ne 0 ]; then
            send_notification "Error en comando" "Comando fall√≥ con c√≥digo $exit_code" "critical"
        else
            notify_long_command "$history[1]" "$duration"
        fi
        
        rm "$LAST_COMMAND_FILE"
    fi
}

preexec() {
    echo $(date +%s) > "$LAST_COMMAND_FILE"
}
```

::: {.callout-tip}
## Tips para utilidades
- Combina `tealdeer` (comando `tldr`) con `man` para documentaci√≥n completa
- `direnv` es perfecto para proyectos con configuraciones espec√≠ficas
- `starship` puede mostrar informaci√≥n contextual del proyecto actual
- `thefuck` aprende de tus errores comunes
:::

En el pr√≥ximo cap√≠tulo exploraremos combinaciones avanzadas y workflows complejos.
